// SL Classroom Creator
// Copyright Edmund Edgar, 2006-12-23

// This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

string config_notecard = "sloodle_object_configuration";

string sloodleserverroot = ""; //"http://moodle.edochan.com";
string pwd = "";
string pwdcode = "";

string sloodleprofilebase = "/mod/sloodle/sl_classroom/sl_profile.php";

integer object_dialog_channel = -3857343;
integer avatar_dialog_channel = 3857343;
integer avatar_chat_channel = 1;

key http_id; 
integer listen_id;

string toucheravname;
key toucheruuid = NULL_KEY;

string toucherurl = "";

integer sloodle_courseid = 0;

list objectprofileids;
list objectprofilenames;

integer objectbeingrezzedindex;
list objectnames;
list objectuuids;
list objectrelativepositions;
list objectentryids;
integer objectsallrezzed = 0;

integer objectprofileid = 0;
string objectprofilename = "";

list savemeuuids;
list savemenames;
list savemepos;

list ignoremeuuids;
list ignoremenames;

sloodle_debug(string msg)
{
    // llWhisper(0,msg);
}

sloodle_tell_other_scripts_in_prim(string msg)
{
    sloodle_debug("sending message to other scripts: "+msg);
    llMessageLinked(LINK_THIS, object_dialog_channel, msg, NULL_KEY);   
}

display_menu()
{
        list menu_options = [];
        if ( (sloodleserverroot == "") || (pwd == "") ) {
            sloodle_debug("install is "+sloodleserverroot+" and pwd is "+pwd);
            llSay(0,"TODO: figure out what to do here when there is no sloodleserverroot or pwd - maybe this should never happen?");
        } else if ( objectsallrezzed == 1) {
            if (objectprofileid > 0) {
                menu_options = ["Cleanup", "Save", "Save As","Cancel"]; 
            } else {
                menu_options = ["Cleanup", "Save As","Cancel"];
            }  
        } else {
            menu_options = ["Setup Class","Set Moodle","Cancel"];   
        }
        sloodle_debug("showing menu to toucher "+(string)toucheruuid);
        llDialog(toucheruuid, "Menu Options", menu_options, avatar_dialog_channel);
        listen_id = llListen(avatar_dialog_channel, "", toucheruuid, "");
}


request_course_profiles() 
{
    sloodle_debug("Fetching data for course "+(string)sloodle_courseid);
    string url = sloodleserverroot + sloodleprofilebase + "?cmd=listprofiles&pwd=" + pwd;
    url = url+"&avname="+llEscapeURL(toucheravname)+"&uuid="+(string)toucheruuid+"&courseid="+(string)sloodle_courseid;
    http_id = llHTTPRequest(url,[],"");
}

integer handle_profile_selection(string message) 
{
    integer i;
    for (i=0;i<llGetListLength(objectprofileids);i++) {
        if (message == llList2String(objectprofilenames,i)) {
            objectprofileid = llList2Integer(objectprofileids,i);
            
            // Cleanup the ones we didn't choose
            objectprofileids = [];
            objectprofilenames = [];
            
            return 1;
        }
    }
    return 0;
}

fetch_profile_entry_data()
{
    sloodle_debug("Fetching data for profileid "+(string)objectprofileid);        
    string url = sloodleserverroot + sloodleprofilebase + "?cmd=entries&pwd=" + pwd;
    url = url+"&avname="+llEscapeURL(toucheravname)+"&uuid="+(string)toucheruuid+"&profileid="+(string)objectprofileid+"&courseid="+(string)sloodle_courseid;
    // llWhisper(0,"Requesting login URL for "+llDetectedName(0));
    http_id = llHTTPRequest(url,[],"");
}

handle_course_profile_response(string body)
{
    
    //sloodle_debug("course_profile_response:"+body);

    list lines = llParseString2List(body,["\n"],[]);
    string firstline = llList2String(lines,0);
    list data = llParseString2List(firstline,["|"],[]);                
    string resultCode = llList2String(data,0);
          
        if(resultCode == "ERROR") {
            llWhisper(0,"Sorry, I tried to get some data out of Moodle but it didn't work out...");
            integer i;
            for (i=1;i<llGetListLength(data);i++) {                
                sloodle_debug(":" + llList2String(data,i) + ":" + (string)i);   
            }
        } else {            
        
            objectprofileids = [];
            objectprofilenames = [];
            // objectprofilecounts = [];
                        
            integer i;
            for (i=0;i<llGetListLength(lines);i++) {
                string curline = llList2String(lines,i); 
                data = llParseString2List(curline,["|"],[]); 
                objectprofileids = objectprofileids + [llList2Integer(data,1)];
                objectprofilenames = objectprofilenames + [llList2String(data,2)];
                // objectprofilecounts = objectprofilecounts + [llList2String(data,3)];
            }
                            
            sloodle_debug("Loaded profiles");
            
            offer_profile_select();
                                                                                        
        }           
   
   
}

offer_profile_select()
{
    llDialog(toucheruuid, "Choose your profile", objectprofilenames, avatar_dialog_channel);
    llListen(avatar_dialog_channel, "", toucheruuid, "");       
}

integer handle_profile_entry_reponse(string body)
{
    
    sloodle_debug("Got course settings"+body);                    
    list lines = llParseString2List(body,["\n"],[]);
    string firstline = llList2String(lines,0);
    list data = llParseString2List(firstline,["|"],[]);                
    string resultCode = llList2String(data,0);       

    if(resultCode == "ERROR") {
        llWhisper(0,"Sorry, I tried to get some data out of Moodle but it didn't work out...");
        integer i;
        for (i=1;i<llGetListLength(data);i++) {            
            sloodle_debug(":" + llList2String(data,i) + ":" + (string)i);   
        }
        
        return 0;
        
    } else {
    // TODO: Populate objects...
        objectbeingrezzedindex = 0;
                    
        objectentryids = [];
        objectnames = [];         
        objectuuids = [];
        objectrelativepositions = [];
        
        sloodle_debug("ready to populate objects");
        
        integer i;
        for (i=0;i<llGetListLength(lines);i++) {
            string curline = llList2String(lines,i);
            data = llParseString2List(curline,["|"],[]);
                        
            // we'll fill in objectuuids when we rez the objets
            objectentryids = objectentryids + [llList2Integer(data,1)];
            objectnames = objectnames + [llList2String(data,2)];
            objectrelativepositions = objectrelativepositions + [(vector)llList2String(data,3)];                                          
        }

        return 1;                             
                    
    }    
}

// Controlling objects

object_command(key uuid, string msg) {
    // TODO: say or shout or whatever depending on distance
    llSay(object_dialog_channel, (string)uuid+"|"+msg);    
    sloodle_debug("COMMAND SENT:"+(string)uuid+":"+msg);
}

object_initialize(key uuid)
{
    // Tell the object the sloodle install url    
    
    string trustmecode = llGetSubString((string)pwdcode,0,3); // pass the first 4 digits of the opwd we gave the object when we rezzed it. This will prove that we are the rezzer.
    object_command(uuid, "set:controllercode|"+trustmecode);
    object_command(uuid, "set:sloodleserverroot|"+sloodleserverroot);
    object_command(uuid, "set:sloodle_courseid|"+(string)sloodle_courseid);
}

integer object_entry_id_for_uuid(key uuid) {
    // TODO: find an entry id for this uuid, if there is one.
    integer i;
    for (i=0; i<llGetListLength(objectuuids); i++) {
        if (uuid == llList2Key(objectuuids, i)) {
            return llList2Integer(objectentryids, i);
        }
    }
    return 0;
}

rez_sloodle_prim(string name, vector relative_position, integer intopwd)
{
    llRezObject(name, llGetPos() + relative_position, ZERO_VECTOR, ZERO_ROTATION, intopwd);        
}
                         
rez_all_objects()
{
    
    objectbeingrezzedindex = -1;
    rez_next_object(); // rezzing the following object will be called by the object_rez event 

}

// rez the next object in the list, return 1 if it rezzes something, 0 if there's othing left to rez
// TODO: Set a timer to deal with if the object fails to rez...
integer rez_next_object()
{
    objectbeingrezzedindex++;
    if (llGetListLength(objectnames) > objectbeingrezzedindex) {
        sloodle_debug("Rezzing object "+llList2String(objectnames,objectbeingrezzedindex));
        rez_sloodle_prim(llList2String(objectnames,objectbeingrezzedindex), llList2Vector(objectrelativepositions,objectbeingrezzedindex), (integer)pwdcode);
        return 1;
    }
    return 0;
}

save_current_objects(integer profile_id)
{
    integer i;
    for (i=0;i<llGetListLength(objectuuids);i++) {
        object_command(llList2Key(objectuuids,i),"SAVE:"+(string)profile_id);
    }       
}

integer handle_new_profile_reponse(string body)
{
    list data = llParseString2List(body,["|"],[]); 
    if (llList2String(data,0) == "OK") {
        objectprofileid = llList2Integer(data,1);
        objectprofilename = llList2String(data,2);        
        return 1;
    } else {        
        sloodle_debug(llList2String(data,1));
        return 0;
    }
}


sloodle_handle_command(string str) 
{
    //llWhisper(0,"handling command "+str);    

    sloodle_debug("classroom creator handing command "+str);
    list bits = llParseString2List(str,["|"],[]);
        string name = llList2String(bits,0);
        string value = llList2String(bits,1);
        if (name == "set:sloodleserverroot") {
            sloodleserverroot = value;
        } else if (name == "set:pwd") {
            pwd = value;
            if (llGetListLength(bits) == 3) {
                pwdcode = llList2String(bits,2);
                pwd = pwd + "|" + pwdcode;
            }
        } else if (name == "set:sloodle_courseid") {
            sloodle_courseid = (integer)value;
        } else if (name == "set:toucheruuid") {
            toucheruuid = (key)value;            
        }
    

    //llWhisper(0,"DEBUG: "+sloodleserverroot+"/"+pwd+"/"+(string)sloodle_courseid);

    if ( (sloodleserverroot != "") && (pwd != "") && (sloodle_courseid != 0)  && (toucheruuid != NULL_KEY) ) {
        sloodle_debug("going to state course_profiles");
        state course_profiles;
    }
}

default 
{
    on_rez(integer start_param)
    {
        llResetScript();
    }       
    touch_start(integer total_number)
    {
        if ( (sloodleserverroot == "") || (pwd == "") || (sloodle_courseid == 0) ) {
            sloodle_debug("Waiting for configuration");
            state sloodle_wait_for_configuration;
        } else {
            state menu;
        }
    }
    listen(integer channel, string name, key id, string message) {
        state menu;   
    }   
}


state sloodle_wait_for_configuration
{
    state_entry() {
        sloodle_debug("Waiting for command");
        //llWhisper(0,"waiting for command");
    }
    link_message(integer sender_num, integer num, string str, key id) {
        sloodle_debug("got message "+(string)sender_num+str);
       // if ( (sender_num == LINK_THIS) && (num == sloodle_command_channel) ){
            sloodle_handle_command(str);
        //}   
    }
}


state menu
{
    state_entry()
    {
        display_menu();   

    }
    listen(integer channel, string name, key id, string message)
    {
        //llWhisper(0,"message was "+message);
        if (message == "Save") {
            state save;
        } else if (message == "Save As") {
            state new_profile;
        } else if (message == "Cleanup") {
            state cleanup;            
        } else {
            sloodle_tell_other_scripts_in_prim("handlemenu|"+message);
            llListenRemove(listen_id);
            state sloodle_wait_for_configuration;
        }
    }

}

state course_profiles
{
    touch_start(integer total_number) {
        state menu;   
    }    
    state_entry() {
        request_course_profiles();
    }    
    http_response(key request_id, integer status, list metadata, string body) {
        if(status == 200) {
            if (request_id == http_id) {
                handle_course_profile_response(body);              
            }
        }
    }
    listen(integer channel, string name, key id, string message)
    {
        integer ok = handle_profile_selection(message);
        if (ok == 1) {
            state object_creation;   
        }
    }
}

state object_creation
{
    state_entry() {
        fetch_profile_entry_data();
    }
    object_rez(key id) {
        objectuuids = objectuuids + [id];
        object_initialize(id);
        integer something_rezzed = rez_next_object();
        if (something_rezzed == 0) {
            objectsallrezzed = 1;
            state default;
        }
    }  
    http_response(key request_id, integer status, list metadata, string body) {
        if(status == 200) {
            if (request_id == http_id) {
                integer ok = handle_profile_entry_reponse(body);
                if (ok == 1) {
                    rez_all_objects();;
                }
            }
        }
    }  
}

state new_profile
{
    touch_start(integer total_number) {
        state menu;   
    }    
    state_entry() {
        llWhisper(0,"Enter name for profile, eg /1 My Profile:");
        listen_id = llListen(avatar_chat_channel, "", toucheruuid, "");
    }
    listen(integer channel, string name, key id, string message) {
        string url = sloodleserverroot+sloodleprofilebase+"?pwd="+pwd+"&cmd=new&name="+llEscapeURL(message)+"&courseid="+(string)sloodle_courseid+"&avname="+toucheravname+"&uuid="+(string)toucheruuid;        
        sloodle_debug("new profile:"+url);
        http_id = llHTTPRequest(url,[],"");
        llListenRemove(listen_id);
    }
    http_response(key request_id, integer status, list metadata, string body) {        
        sloodle_debug("got response"+body);
        if(status == 200) {
            if (request_id == http_id) {
                integer ok = handle_new_profile_reponse(body);
                if (ok == 1) {
                    state save;
                } else {
                    llWhisper(0,"Failed, please try again");
                    listen_id = llListen(0, "", toucheruuid, "");
                }
            }
        }
    }
    
}

state save
{    

    touch_start(integer total_number) {
        state menu;   
    }    
    state_entry() { 
    llSay(0,"in state save in classroom_creator");       
        integer sloodle_save_channel = -3524564;
        sloodle_debug("in state entry save");    
        string baseurl = sloodleserverroot+sloodleprofilebase+"?pwd="+pwd+"&cmd=addentries&profileid="+(string)objectprofileid+"&avname="+toucheravname+"&uuid="+(string)toucheruuid;
        llMessageLinked(LINK_THIS, sloodle_save_channel, baseurl, NULL_KEY);   // send a message to the saving script
    }
    
}

state cleanup
{
    touch_start(integer total_number) {
        state menu;   
    }    
    state_entry() {
        integer i;
        for (i=0;i<llGetListLength(objectuuids);i++) {
            object_command(llList2Key(objectuuids,i),"CLEANUP");
        }
        objectsallrezzed = 0;          
    }    
    // TODO: Check each object is cleaned up... 
}
