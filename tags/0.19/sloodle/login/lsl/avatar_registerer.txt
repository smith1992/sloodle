// SL Classroom Access Controller
// Copyright Edmund Edgar, 2006-01-20

// When someone enters (or for now, touches), authenticate them and show a list of course they're allowed to take.

// Only handles one user at a time for now...

// This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

string sloodleserverroot = ""; // "http://moodle.edochan.com";
string pwd = ""; //""; 

string sloodleregurlbase = "/mod/sloodle/login/sl_sloodle_reg.php";
string sloodlewelcomebase = "/mod/sloodle/login/sl_welcome_reg.php";

integer SLOODLE_CHANNEL_AVATAR_IGNORE = -1639279999;

integer object_dialog_channel = -3857343;
integer avatar_dialog_channel = 3857343;

integer sloodle_courseid = 0; //3;

list avstates; // each avatar gets their own state saying where in the validation process they are.
list avuuids;
list avhttpids;

 
sloodle_debug(string msg)
{
     //llWhisper(0,msg);
}

require_sloodle_registration(integer avindex,key uuid)
{
    string sloodleregurl = sloodleserverroot + sloodleregurlbase + "?pwd=" + pwd;
    string url = sloodleregurl+"&avname="+llEscapeURL(llKey2Name(uuid))+"&uuid="+(string)uuid;
    sloodle_debug("Requesting login URL for "+llDetectedName(0));
    avhttpids = llListReplaceList(avhttpids,[llHTTPRequest(url,[],"")],avindex, avindex);
}

integer handle_authentication_response(string body) 
{
    list data = llParseString2List(body,["|"],[]);
    string resultCode = llList2String(data,0);

    if(resultCode == "ERROR") {
        
        if(llList2String(data,2) == "user already registered with all the info sloodle needs") {
            sloodle_debug("user already registered");
            return -1;  
        } else {
            //llWhisper(0,"Sorry, I tried to get some data out of Moodle but it didn't work out...");
            integer i;
            for (i=1;i<llGetListLength(data);i++) {
                //sloodle_debug(":" + llList2String(data,i) + ":" + (string)i);
            }
        }
    } else {
        key uuid = llList2Key(data,1);
        string code = llList2String(data,2);                    
        string sloodlewelcomeurl = sloodleserverroot + sloodlewelcomebase;
        llLoadURL(uuid,"Go here and login to Moodle",sloodlewelcomeurl+"?lsc="+code);
    }
    return 0;
}

sloodle_handle_command(string str) 
{
    //llWhisper(0,"handling command "+str);    
    list bits = llParseString2List(str,["|"],[]);
        string name = llList2String(bits,0);
        string value = llList2String(bits,1);
        if (name == "set:sloodleserverroot") {
            sloodleserverroot = value;
        } else if (name == "set:pwd") {
            pwd = value;
            if (llGetListLength(bits) == 3) {
                pwd = pwd + "|" + llList2String(bits,2);
            }
        } else if (name == "set:sloodle_courseid") {
            sloodle_courseid = (integer)value;
        }
    
    //llWhisper(0,"DEBUG: "+sloodleserverroot+"/"+pwd+"/"+(string)sloodle_courseid);

    if ( (sloodleserverroot != "") && (pwd != "") ) {
        state default;
    }
}

sloodle_init()
{
    //llWhisper(0,"initializing");    
    if ( (sloodleserverroot == "") || (pwd == "") ) {
        state sloodle_wait_for_configuration;
    }
    //llVolumeDetect(TRUE); 
}

default 
{
    on_rez(integer param)
    {
        sloodle_init();
    }
    state_entry()
    {
        sloodle_init();
    }    
    touch_start(integer total_number)
    {
        sloodle_debug("total_number is "+(string)total_number);        
        sloodle_debug("Detected avatar "+llDetectedName(0));
        // see if we're already working with them
        integer avindex = llListFindList(avuuids, [llDetectedKey(0)]);
        if (avindex == -1) {
            sloodle_debug("first time we've seen "+llDetectedName(0));
            avuuids = avuuids + [llDetectedKey(0)];
            avindex = llListFindList(avuuids, [llDetectedKey(0)]);
            avstates = avstates + ["authentication"];
            avhttpids = avhttpids + [NULL_KEY];
        } else {
            sloodle_debug("have previously seen "+llDetectedName(0)+" at index "+(string)avindex);
            llListReplaceList(avstates,["authentication"],avindex,avindex);
            llListReplaceList(avhttpids,[NULL_KEY],avindex,avindex);
        }
        sloodle_debug("checking registration for index "+(string)avindex+" and key "+(string)llDetectedKey(0));
        require_sloodle_registration(avindex,llDetectedKey(0));  
     }

    http_response(key request_id, integer status, list metadata, string body) {
        sloodle_debug("handing request "+body);
        if(status == 200) {
            integer avindex = llListFindList(avhttpids, [request_id]);
            if(avindex != -1) {
                string avstate = llList2String(avstates, avindex);
                sloodle_debug("avstate is "+avstate+" for uuid index "+(string)avindex);
                if (avstate == "authentication") {
                    integer ok = handle_authentication_response(body);
                    if (ok == 1) {
                        avstates = llListReplaceList(avstates,["registered"],avindex,avindex);
                        key uuid = llList2Key(avuuids,avindex);            
                        llDialog(uuid,"You have been registered in Sloodle.",["OK"],SLOODLE_CHANNEL_AVATAR_IGNORE);
                    } else if (ok == -1) {
                        key uuid = llList2Key(avuuids,avindex);            
                        llDialog(uuid,"You were already registered in Sloodle.",["OK"],SLOODLE_CHANNEL_AVATAR_IGNORE);                        
                    }
                }          
            } else {
                sloodle_debug("Could not find http id "+(string)request_id);
            }
        }
    }                
}

state sloodle_wait_for_configuration
{
    link_message(integer sender_num, integer num, string str, key id) {
        sloodle_handle_command(str);
    }
}

