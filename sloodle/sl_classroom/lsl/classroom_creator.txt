// SL Classroom Access Controller
// Copyright Edmund Edgar, 2006-01-20

// When someone enters (or for now, touches), authenticate them and show 
a list of course they're allowed to take.

// Only handles one user at a time for now...

// This program is free software; you can redistribute it and/or modify 
it under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2 of the License, or (at your 
option) any later version.

string sloodleserverroot = ""; // "http://moodle.edochan.com";
string pwd = ""; //""; 

string sloodleregurlbase = "/mod/sloodle/login/sl_sloodle_reg.php";
string sloodlewelcomebase = "/mod/sloodle/login/sl_welcome_reg.php";
string sloodlestudentcoursesbase = 
"/mod/sloodle/login/sl_student_courses.php";

integer object_dialog_channel = -3857343;
integer avatar_dialog_channel = 3857343;

integer sloodle_courseid = 0; //3;

list avstates; // each avatar gets their own state saying where in the 
validation process they are.
list avuuids;
list avhttpids;


sloodle_debug(string msg)
{
     //llWhisper(0,msg);
}

require_sloodle_registration(integer avindex,key uuid)
{
    string sloodleregurl = sloodleserverroot + sloodleregurlbase + 
"?pwd=" + pwd;
    string url = 
sloodleregurl+"&avname="+llEscapeURL(llKey2Name(uuid))+"&uuid="+(string)uuid;
    // llWhisper(0,"Requesting login URL for "+llDetectedName(0));
    avhttpids = 
llListReplaceList(avhttpids,[llHTTPRequest(url,[],"")],avindex, 
avindex);
}

integer handle_already_registered()
{
    sloodle_debug("User already registered in Sloodle...");
    return 1;
}

confirm_course_membership(integer avindex)
{
    key uuid = llList2Key(avuuids,avindex);
    string url = sloodleserverroot + sloodlestudentcoursesbase + "?pwd=" 
+ pwd + "&type=all&courseid=" + (string)sloodle_courseid;
    url = 
url+"&avname="+llEscapeURL(llKey2Name(uuid))+"&uuid="+(string)uuid;
    sloodle_debug("Requesting login URL for "+llDetectedName(0));
    avhttpids = 
llListReplaceList(avhttpids,[llHTTPRequest(url,[],"")],avindex, 
avindex);    
}

integer handle_authentication_response(string body) 
{
    list data = llParseString2List(body,["|"],[]);
    string resultCode = llList2String(data,0);
    if(resultCode == "ERROR") {
        if(llList2String(data,2) == "user already registered with all 
the info sloodle needs") {
            return handle_already_registered();  
        } else {
            llWhisper(0,"Sorry, I tried to get some data out of Moodle 
but it didn't work out...");
            integer i;
            for (i=1;i<llGetListLength(data);i++) {
                sloodle_debug(":" + llList2String(data,i) + ":" + 
(string)i);
            }
        }
    } else {
        key uuid = llList2Key(data,1);
        string code = llList2String(data,2);                    
        string sloodlewelcomeurl = sloodleserverroot + 
sloodlewelcomebase;
        llLoadURL(uuid,"Go here and login to 
Moodle",sloodlewelcomeurl+"?lsc="+code);
    }
    return 0;
}

integer handle_course_membership_confirmation_response(string body) 
{
    list data = llParseString2List(body,["|"],[]);
    string resultCode = llList2String(data,0);
    if(resultCode == "ERROR") {
        llWhisper(0,"Sorry, I tried to get some data out of Moodle but 
it didn't work out...");
    } else {
        key uuid = llList2Key(data,1);
        string code = llList2String(data,2); 
        string name = llList2String(data,3); 
        string role = llList2String(data,4); // TODO: This should tell 
us if they're a teacher or not...
        string status = llList2String(data,5);                                        
        if (status == "enrolled") {
            llWhisper(0,"Welcome to the "+name+" classroom, 
"+llKey2Name(uuid));   
            return 1;
        } else if (status == "enrollable") {
            llWhisper(0,llKey2Name(uuid)+", you are not signed up for 
the class "+name+". You should soon be able to press a button here to 
enrol automatically, but for now you'll have to go to the website...");            
        } else {
          llWhisper(0,llKey2Name(uuid)+", you are not signed up for the 
class "+name+" and it is not accepting registrations. Please leave the 
classroom.");             
        }
    }
    return 0;
}

sloodle_handle_command(string str) 
{
    //llWhisper(0,"handling command "+str);    
    list bits = llParseString2List(str,["|"],[]);
        string name = llList2String(bits,0);
        string value = llList2String(bits,1);
        if (name == "set:sloodleserverroot") {
            sloodleserverroot = value;
        } else if (name == "set:pwd") {
            pwd = value;
            if (llGetListLength(bits) == 3) {
                pwd = pwd + "|" + llList2String(bits,2);
            }
        } else if (name == "set:courseid") {
            sloodle_courseid = (integer)value;
        }
    
    //llWhisper(0,"DEBUG: 
"+sloodleserverroot+"/"+pwd+"/"+(string)sloodle_courseid);

    if ( (sloodleserverroot != "") && (pwd != "") && (sloodle_courseid 
!= 0) ) {
        state default;
    }
}

sloodle_init()
{
    //llWhisper(0,"initializing");    
    if ( (sloodleserverroot == "") || (pwd == "") || (sloodle_courseid 
== 0) ) {
        state sloodle_wait_for_configuration;
    }
    llVolumeDetect(TRUE); 
}

default 
{
    on_rez(integer param)
    {
        sloodle_init();
    }
    state_entry()
    {
        sloodle_init();
    }    
    collision_start(integer total_number)
    {
        sloodle_debug("Detected avatar "+llDetectedName(0));
        // see if we're already working with them
        integer avindex = llListFindList(avuuids, [llDetectedKey(0)]);
        if (avindex == -1) {
            avuuids = avuuids + [llDetectedKey(0)];
            avindex = llListFindList(avuuids, [llDetectedKey(0)]);
            avstates = avstates + ["authentication"];
            avhttpids = avhttpids + [NULL_KEY];
        } else {
            
llListReplaceList(avstates,["authentication"],avindex,avindex);
            llListReplaceList(avhttpids,[NULL_KEY],avindex,avindex); 
        }
               
        require_sloodle_registration(avindex,llDetectedKey(0));  
     }

    http_response(key request_id, integer status, list metadata, string 
body) {
        sloodle_debug("handing request "+body);
        if(status == 200) {
            integer avindex = llListFindList(avhttpids, [request_id]);
            if(avindex != -1) {
                string avstate = llList2String(avstates, avindex);
                if (avstate == "authentication") {
                    integer ok = handle_authentication_response(body);
                    if (ok == 1) {
                        avstates = 
llListReplaceList(avstates,["course_confirmation"],avindex,avindex);
                        confirm_course_membership(avindex);
                    }
                } else if (avstate == "course_confirmation") {
                    integer allowed = 
handle_course_membership_confirmation_response(body);                    
                }         
            } else {
                sloodle_debug("Could not find http id 
"+(string)request_id);
            }
        }
    }                
}

state sloodle_wait_for_configuration
{
    link_message(integer sender_num, integer num, string str, key id) {
        sloodle_handle_command(str);
    }
}

