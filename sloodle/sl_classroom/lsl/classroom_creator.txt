// SL Classroom Creator
// Copyright Edmund Edgar, 2006-12-23

// This program is free software; you can redistribute it and/or modify it under the terms of the 
GNU General Public License as published by the Free Software Foundation; either version 2 of the 
License, or (at your option) any later version.

string config_notecard = "sloodle_object_configuration";

string sloodleinstall = ""; //"http://moodle.edochan.com";
string pwd = "";
string pwdcode = "";

string sloodleregurlbase = "/mod/sloodle/login/sl_sloodle_reg.php";
string sloodlewelcomebase = "/mod/sloodle/login/sl_welcome_reg.php";
string sloodleteachercoursesbase = "/mod/sloodle/login/sl_teacher_courses.php";
string sloodleobjectvalidationbase = "/mod/sloodle/sl_classroom/sl_validate_object.php";
string sloodleprofilebase = "/mod/sloodle/sl_classroom/sl_profile.php";

integer object_dialog_channel = -3857343;
integer avatar_dialog_channel = 3857343;
integer avatar_chat_channel = 1;

integer emailpollinterval = 5;
integer emailtimeuntilgiveup = 3600;
integer emailtriessofar = 0;

key http_id; 
integer listen_id;

string toucheravname;
key toucheruuid;

string toucherurl = "";

integer courseid = 0;
list courseids;
list coursetitles;
list coursecodes;

list objectprofileids;
list objectprofilenames;

integer objectbeingrezzedindex;
list objectnames;
list objectuuids;
list objectrelativepositions;
list objectentryids;
integer objectsallrezzed = 0;

integer objectprofileid = 0;
string objectprofilename = "";

list savemeuuids;
list savemenames;
list savemepos;

list ignoremeuuids;
list ignoremenames;

sloodle_debug(string msg)
{
     //llWhisper(0,msg);
}

display_menu()
{
        list menu_options = [];
        if ( (sloodleinstall == "") || (pwd == "") ) {
            sloodle_debug("install is "+sloodleinstall+" and pwd is "+pwd);
            menu_options = ["Set Moodle","Cancel"];
        } else if ( objectsallrezzed == 1) {
            if (objectprofileid > 0) {
                menu_options = ["Cleanup", "Save", "Save As","Cancel"]; 
            } else {
                menu_options = ["Cleanup", "Save As","Cancel"];
            }  
        } else {
            menu_options = ["Setup Class","Set Moodle","Cancel"];   
        }
        llDialog(toucheruuid, "Menu Options", menu_options, avatar_dialog_channel);
        listen_id = llListen(avatar_dialog_channel, "", toucheruuid, "");
}

// Moodle selection
// For when the object doesn't yet know which server it should be using...
// ... and the server doesn't yet know whether it should trust this object.
require_sloodle_install_input_and_validation()
{
    sloodleinstall = "";
    pwd = "";  
    pwdcode = "";  
    llWhisper(0,toucheravname+", please tell me the URL of your Moodle installation, eg. /1 
http://moodle.edochan.com");  
    llListen(avatar_chat_channel,"",toucheruuid,"");
}   

integer handle_server_selection_input(string msg)
{
    toucherurl = msg;
    sloodle_debug("handling server input "+msg);
    string url = msg + sloodleobjectvalidationbase;
    http_id = llHTTPRequest(url,[],"");     
    return 1;
}

integer handle_server_selection_response(string body)
{
    llLoadURL(toucheruuid,"Login to Moodle and confirm that you trust this 
object",toucherurl+sloodleobjectvalidationbase+"?objuuid="+(string)llGetKey()+"&objname="+llEscapeURL(llGetObjectName()));
    emailtriessofar = 0;
    llSetTimerEvent(emailpollinterval); // start checking to see if the server sends us an 
e-mail... 
    return 1;    
}

integer handle_authentication_email(string message) 
{
    list data = llParseString2List(message,["|"],[]);
    if (toucherurl+sloodleobjectvalidationbase == llList2String(data,0)) {
        sloodleinstall = toucherurl;
        pwdcode = llList2String(data,1);
        pwd = (string)llGetKey()+"|"+pwdcode;
        sloodle_debug("Email response was ok");
        return 1;
    } else {
        sloodle_debug("Ignoring message "+message+" - url "+llList2String(data,0)+" did not match 
toucher supplied url "+toucherurl); 
        return 0;   
    }
}

integer handle_server_selection_404()
{
    string url = toucherurl+"/index.php";
    http_id = llHTTPRequest(url,[],"");     
    return 1;    
}

handle_site_missing_sloodle() 
{
    llWhisper(0, "Could not find the Sloodle files at "+toucherurl+". Please make sure that you 
have typed the URL correctly, and that the Sloodle module is installed as mod/sloodle.");
}

handle_site_missing() {
    llWhisper(0, "Could not get a response from the URL"+toucherurl+". Please check and try 
again.");       
}

require_sloodle_registration()
{
    string sloodleregurl = sloodleinstall + sloodleregurlbase + "?pwd=" + pwd;
    string url = 
sloodleregurl+"&avname="+llEscapeURL(toucheravname)+"&uuid="+(string)toucheruuid;
    // llWhisper(0,"Requesting login URL for "+llDetectedName(0));
    http_id = llHTTPRequest(url,[],"");
}

integer handle_already_registered()
{
    sloodle_debug("User already registered in Sloodle...");
    return 1;
}

integer handle_authentication_response(string body) 
{
    list data = llParseString2List(body,["|"],[]);
    string resultCode = llList2String(data,0);
    if(resultCode == "ERROR") {
        if(llList2String(data,2) == "user already registered with all the info sloodle needs") {
            return handle_already_registered();  
        } else {
            llWhisper(0,"Sorry, I tried to get some data out of Moodle but it didn't work 
out...");
            integer i;
            for (i=1;i<llGetListLength(data);i++) {
                sloodle_debug(":" + llList2String(data,i) + ":" + (string)i);
            }
        }
    } else {
        key uuid = llList2Key(data,1);
        string code = llList2String(data,2);                    
        string sloodlewelcomeurl = sloodleinstall + sloodlewelcomebase;
        llLoadURL(uuid,"Go here and login to Moodle",sloodlewelcomeurl+"?lsc="+code);
    }
    return 0;
}

request_teacher_courses()
{
    string url = sloodleinstall + sloodleteachercoursesbase + "?pwd=" + pwd;
    url = url+"&avname="+llEscapeURL(toucheravname)+"&uuid="+(string)toucheruuid;
    // llWhisper(0,"Requesting login URL for "+llDetectedName(0));
    http_id = llHTTPRequest(url,[],"");    
}

handle_teacher_courses_response(string body)
{
    list lines = llParseString2List(body,["\n"],[]);
    string firstline = llList2String(lines,0);
    list data = llParseString2List(firstline,["|"],[]);                
    string resultCode = llList2String(data,0);
    key responseuuid = llList2Key(data,1);
    if (responseuuid == toucheruuid) {            
        if(resultCode == "ERROR") {
            llWhisper(0,"Sorry, I tried to get some data out of Moodle but it didn't work 
out...");
            integer i;
            for (i=1;i<llGetListLength(data);i++) {
                sloodle_debug(":" + llList2String(data,i) + ":" + (string)i);   
            }
        } else {            
        
            courseids = [];
            coursetitles = [];
            coursecodes = [];
                        
            integer i;
            for (i=0;i<llGetListLength(lines);i++) {
                string curline = llList2String(lines,i); 
                data = llParseString2List(curline,["|"],[]); 
                courseids = courseids + [llList2Integer(data,2)];
                coursecodes = coursecodes + [llList2String(data,3)];
                coursetitles = coursetitles + [llList2String(data,4)];
            }
            sloodle_debug("Loaded courses");

            offer_course_select();
                                                                                        
        }           
    } else {
        sloodle_debug("User has changed - ignoring old response");
    }   
}

offer_course_select() // TODO: Make sure the avatar getting this is the one who requested the 
course list...
{
    llDialog(toucheruuid, "Choose your course",coursecodes, avatar_dialog_channel);
    llListen(avatar_dialog_channel, "", toucheruuid, "");
}

integer handle_course_selection_response(string msg) 
{
    sloodle_debug("course selection is "+msg);
    
    integer found = 0;
    integer i;   
    for (i=0;i<llGetListLength(coursecodes);i++) {
        if (llList2String(coursecodes, i) == msg) {            
            sloodle_debug("Set courseid "+(string)llList2Integer(courseids,i));
            courseid = llList2Integer(courseids, i);     
            found = 1;
        }        
    }
    if (found == 0) {
        llWhisper(0,"Could not find a course for the code "+msg+". Maybe something is being 
updated at the moment?");
    }
    
    // cleanup
    coursecodes = [];
    coursetitles = [];
    courseids = [];
    
    return found;
}

request_course_profiles() 
{
    sloodle_debug("Fetching data for course "+(string)courseid);
    string url = sloodleinstall + sloodleprofilebase + "?cmd=listprofiles&pwd=" + pwd;
    url = 
url+"&avname="+llEscapeURL(toucheravname)+"&uuid="+(string)toucheruuid+"&courseid="+(string)courseid;
    http_id = llHTTPRequest(url,[],"");
}

integer handle_profile_selection(string message) 
{
    integer i;
    for (i=0;i<llGetListLength(objectprofileids);i++) {
        if (message == llList2String(objectprofilenames,i)) {
            objectprofileid = llList2Integer(objectprofileids,i);
            
            // Cleanup the ones we didn't choose
            objectprofileids = [];
            objectprofilenames = [];
            
            return 1;
        }
    }
    return 0;
}

fetch_profile_entry_data()
{
    sloodle_debug("Fetching data for profileid "+(string)objectprofileid);        
    string url = sloodleinstall + sloodleprofilebase + "?cmd=entries&pwd=" + pwd;
    url = 
url+"&avname="+llEscapeURL(toucheravname)+"&uuid="+(string)toucheruuid+"&profileid="+(string)objectprofileid;
    // llWhisper(0,"Requesting login URL for "+llDetectedName(0));
    http_id = llHTTPRequest(url,[],"");
}

handle_course_profile_response(string body)
{
    
    //sloodle_debug("course_profile_response:"+body);

    list lines = llParseString2List(body,["\n"],[]);
    string firstline = llList2String(lines,0);
    list data = llParseString2List(firstline,["|"],[]);                
    string resultCode = llList2String(data,0);
          
        if(resultCode == "ERROR") {
            llWhisper(0,"Sorry, I tried to get some data out of Moodle but it didn't work 
out...");
            integer i;
            for (i=1;i<llGetListLength(data);i++) {                
                sloodle_debug(":" + llList2String(data,i) + ":" + (string)i);   
            }
        } else {            
        
            objectprofileids = [];
            objectprofilenames = [];
            // objectprofilecounts = [];
                        
            integer i;
            for (i=0;i<llGetListLength(lines);i++) {
                string curline = llList2String(lines,i); 
                data = llParseString2List(curline,["|"],[]); 
                objectprofileids = objectprofileids + [llList2Integer(data,1)];
                objectprofilenames = objectprofilenames + [llList2String(data,2)];
                // objectprofilecounts = objectprofilecounts + [llList2String(data,3)];
            }
                            
            sloodle_debug("Loaded profiles");
            
            offer_profile_select();
                                                                                        
        }           
   
   
}

offer_profile_select()
{
    llDialog(toucheruuid, "Choose your profile", objectprofilenames, avatar_dialog_channel);
    llListen(avatar_dialog_channel, "", toucheruuid, "");       
}

integer handle_profile_entry_reponse(string body)
{
    
    sloodle_debug("Got course settings"+body);                    
    list lines = llParseString2List(body,["\n"],[]);
    string firstline = llList2String(lines,0);
    list data = llParseString2List(firstline,["|"],[]);                
    string resultCode = llList2String(data,0);       

    if(resultCode == "ERROR") {
        llWhisper(0,"Sorry, I tried to get some data out of Moodle but it didn't work out...");
        integer i;
        for (i=1;i<llGetListLength(data);i++) {            
            sloodle_debug(":" + llList2String(data,i) + ":" + (string)i);   
        }
        
        return 0;
        
    } else {
    // TODO: Populate objects...
        objectbeingrezzedindex = 0;
                    
        objectentryids = [];
        objectnames = [];         
        objectuuids = [];
        objectrelativepositions = [];
        
        sloodle_debug("ready to populate objects");
        
        integer i;
        for (i=0;i<llGetListLength(lines);i++) {
            string curline = llList2String(lines,i);
            data = llParseString2List(curline,["|"],[]);
                        
            // we'll fill in objectuuids when we rez the objets
            objectentryids = objectentryids + [llList2Integer(data,1)];
            objectnames = objectnames + [llList2String(data,2)];
            objectrelativepositions = objectrelativepositions + [(vector)llList2String(data,3)];                                          
        }

        return 1;                             
                    
    }    
}

// Controlling objects

object_command(key uuid, string msg) {
    // TODO: say or shout or whatever depending on distance
    llSay(object_dialog_channel, (string)uuid+"|"+msg);    
    sloodle_debug("COMMAND SENT:"+(string)uuid+":"+msg);
}

object_initialize(key uuid)
{
    // Tell the object the sloodle install url    
    
    string trustmecode = llGetSubString((string)pwdcode,0,3); // pass the first 4 digits of the 
opwd we gave the object when we rezzed it. This will prove that we are the rezzer.
    object_command(uuid, "setcontrollercode|"+trustmecode);
    object_command(uuid, "setsloodleserverroot|"+sloodleinstall);
    object_command(uuid, "setcourseid|"+(string)courseid);
}

integer object_entry_id_for_uuid(key uuid) {
    // TODO: find an entry id for this uuid, if there is one.
    integer i;
    for (i=0; i<llGetListLength(objectuuids); i++) {
        if (uuid == llList2Key(objectuuids, i)) {
            return llList2Integer(objectentryids, i);
        }
    }
    return 0;
}

rez_sloodle_prim(string name, vector relative_position, integer intopwd)
{
    llRezObject(name, llGetPos() + relative_position, ZERO_VECTOR, ZERO_ROTATION, intopwd);        
}
                         
rez_all_objects()
{
    
    objectbeingrezzedindex = -1;
    rez_next_object(); // rezzing the following object will be called by the object_rez event 

}

// rez the next object in the list, return 1 if it rezzes something, 0 if there's othing left to 
rez
// TODO: Set a timer to deal with if the object fails to rez...
integer rez_next_object()
{
    objectbeingrezzedindex++;
    if (llGetListLength(objectnames) > objectbeingrezzedindex) {
        sloodle_debug("Rezzing object "+llList2String(objectnames,objectbeingrezzedindex));
        rez_sloodle_prim(llList2String(objectnames,objectbeingrezzedindex), 
llList2Vector(objectrelativepositions,objectbeingrezzedindex), (integer)pwdcode);
        return 1;
    }
    return 0;
}

save_current_objects(integer profile_id)
{
    integer i;
    for (i=0;i<llGetListLength(objectuuids);i++) {
        object_command(llList2Key(objectuuids,i),"SAVE:"+(string)profile_id);
    }       
}

integer handle_new_profile_reponse(string body)
{
    list data = llParseString2List(body,["|"],[]); 
    if (llList2String(data,0) == "OK") {
        objectprofileid = llList2Integer(data,1);
        objectprofilename = llList2String(data,2);        
        return 1;
    } else {        
        sloodle_debug(llList2String(data,1));
        return 0;
    }
}

default 
{
    touch_start(integer total_number)
    {
        llWhisper(0,"Type /"+(string)avatar_chat_channel+" sloodle within 20 seconds for the 
menu");
        toucheruuid = llDetectedKey(0);
        toucheravname = llDetectedName(0);
        listen_id = llListen(avatar_chat_channel,"",toucheruuid,"sloodle");
        llSetTimerEvent(20);  
    }
    listen(integer channel, string name, key id, string message) {
        // ??? Do I need to check again in case this was triggered by another script? Or is 
listen confined to the callin script?
        llListenRemove(listen_id);
        state menu;   
    }
    timer() {
        llListenRemove(listen_id);        
    }
    
}

state menu
{
    state_entry()
    {

        display_menu();   

    }
    listen(integer channel, string name, key id, string message)
    {
        //llWhisper(0,"message was "+message);
        if (message == "Set Moodle")  {
            state server_selection;   
        } else if (message == "Reset Moodle")  {
            state server_selection;             
        } else if (message == "Setup Class") {
            state authentication;
        } else if (message == "Save") {
            state save;
        } else if (message == "Save As") {
            state new_profile;
        } else if (message == "Cleanup") {
            state cleanup;            
        } else {
            llListenRemove(listen_id);
            state default;
        }
    }

}

state server_selection 
{
    touch_start(integer total_number) {
        state menu;   
    }
    state_entry() {
        require_sloodle_install_input_and_validation();  
    }   
    http_response(key request_id, integer status, list metadata, string body) {
        if(status == 200) {
            if (request_id == http_id) {
                handle_server_selection_response(body);
            }
        } else if (status == 404) {
            state server_404_diagnosis;
        }
    }
    listen(integer channel, string name, key id, string message) {
        handle_server_selection_input(message);   
    }
    // xmlrpc appears to be failing - using e-mail instead... also requires a timer...
    remote_data(integer event_type, key channel, key message_id, string sender, integer idata, 
string sdata) {
        pwd = (string)idata;
       // llWhisper(0,"Got pwd "+pwd);
    }

    email(string time, string address, string subj, string message, integer num_left) {
        sloodle_debug("handling email");
        integer ok = handle_authentication_email(message);
        if (ok == 1) {
            state authentication;        
        }
    }
    timer() {
        sloodle_debug("checking for email");
        emailtriessofar++;
        llGetNextEmail("", "SLOODLE AUTH");
        if ((emailtimeuntilgiveup/emailpollinterval) > emailtriessofar) {
            llSetTimerEvent(emailpollinterval);
        }
    }
}

state server_404_diagnosis
{
    touch_start(integer total_number) {
        state menu;   
    }    
    state_entry() {
        handle_server_selection_404();
    }   
    http_response(key request_id, integer status, list metadata, string body) {
        //TODO: if top page is a 404 as well, tell them the server's wrong.
        //      if not, tell them they may be missing the sloodle module.
        if(status == 200) {
            if(request_id == http_id) {
                handle_site_missing_sloodle();
            }
        } else {
            handle_site_missing();   
        }
        state server_selection;
    }
}
state authentication
{
    state_entry() {
        require_sloodle_registration();    
    }
    http_response(key request_id, integer status, list metadata, string body) {
        if(status == 200) {
            if(request_id == http_id) {
                integer ok = handle_authentication_response(body);
                if (ok == 1) {
                    state course_selection;
                }
            }
        }
    }
}

state course_selection
{
    touch_start(integer total_number) {
        state menu;   
    }    
    state_entry() {
        request_teacher_courses();
    }    
    http_response(key request_id, integer status, list metadata, string body) {
        if(status == 200) {
            if (request_id == http_id) {
                handle_teacher_courses_response(body);              
            }
        }
    }
    listen(integer channel, string name, key id, string message)
    {
        integer ok = handle_course_selection_response(message);
        if (ok == 1) {
            state course_profiles;   
        }
    }
}

state course_profiles
{
    touch_start(integer total_number) {
        state menu;   
    }    
    state_entry() {
        request_course_profiles();
    }    
    http_response(key request_id, integer status, list metadata, string body) {
        if(status == 200) {
            if (request_id == http_id) {
                handle_course_profile_response(body);              
            }
        }
    }
    listen(integer channel, string name, key id, string message)
    {
        integer ok = handle_profile_selection(message);
        if (ok == 1) {
            state object_creation;   
        }
    }
}

state object_creation
{
    state_entry() {
        fetch_profile_entry_data();
    }
    object_rez(key id) {
        objectuuids = objectuuids + [id];
        object_initialize(id);
        integer something_rezzed = rez_next_object();
        if (something_rezzed == 0) {
            objectsallrezzed = 1;
            state default;
        }
    }  
    http_response(key request_id, integer status, list metadata, string body) {
        if(status == 200) {
            if (request_id == http_id) {
                integer ok = handle_profile_entry_reponse(body);
                if (ok == 1) {
                    rez_all_objects();;
                }
            }
        }
    }  
}

state new_profile
{
    touch_start(integer total_number) {
        state menu;   
    }    
    state_entry() {
        llWhisper(0,"Enter name for profile:");
        listen_id = llListen(0, "", toucheruuid, "");
    }
    listen(integer channel, string name, key id, string message) {
        string url = 
sloodleinstall+sloodleprofilebase+"?pwd="+pwd+"&cmd=new&name="+llEscapeURL(message)+"&courseid="+(string)courseid+"&avname="+toucheravname+"&uuid="+(string)toucheruuid;        
        sloodle_debug("new profile:"+url);
        http_id = llHTTPRequest(url,[],"");
        llListenRemove(listen_id);
    }
    http_response(key request_id, integer status, list metadata, string body) {        
        sloodle_debug("got response"+body);
        if(status == 200) {
            if (request_id == http_id) {
                integer ok = handle_new_profile_reponse(body);
                if (ok == 1) {
                    state save;
                } else {
                    llWhisper(0,"Failed, please try again");
                    listen_id = llListen(0, "", toucheruuid, "");
                }
            }
        }
    }
    
}

state save
{    

    touch_start(integer total_number) {
        state menu;   
    }    
    state_entry() {        
        integer sloodle_save_channel = -3524563;
        sloodle_debug("in state entry save");    
        string baseurl = 
sloodleinstall+sloodleprofilebase+"?pwd="+pwd+"&cmd=addentries&profileid="+(string)objectprofileid+"&avname="+toucheravname+"&uuid="+(string)toucheruuid;
        llMessageLinked(LINK_THIS, sloodle_save_channel, baseurl, NULL_KEY);   // send a message 
to the saving script
    }
    
}

state cleanup
{
    touch_start(integer total_number) {
        state menu;   
    }    
    state_entry() {
        integer i;
        for (i=0;i<llGetListLength(objectuuids);i++) {
            object_command(llList2Key(objectuuids,i),"CLEANUP");
        }
        objectsallrezzed = 0;          
    }    
    // TODO: Check each object is cleaned up... 
}
